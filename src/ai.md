# Kommune Quiz — AI Context Document

Use this document to understand the project, coding style, architecture, and what to work on next.

## What This Is

An interactive map quiz game where players identify Norwegian kommuner (municipalities) by clicking on them on an SVG map. Built with React + TypeScript + Vite, deployed to Cloudflare Pages.

## Tech Stack

- **React 19** with React Compiler (auto-memoization — avoid manual `useCallback`/`useMemo` where the compiler handles it; the compiler will warn via ESLint if manual memoization conflicts)
- **TypeScript** (strict)
- **Vite** (bundler)
- **d3-geo** (projection/path generation only — no D3 DOM manipulation)
- **topojson-client** (converting TopoJSON → GeoJSON features, `mesh` for border extraction)
- **No component library** — plain CSS, dark theme

## Coding Style & Conventions

- **Norwegian UI text**: all user-facing strings are in Norwegian ("Finn:", "Hopp over", "feil", "Ferdig!", "Spill igjen", "Start på nytt", "Hele Norge")
- **English code**: all variable names, comments, file names are in English, except domain terms (`kommune`, `fylke`, `kommunenummer`, `fylkesnummer`, `fylkenavn`) which stay Norwegian since they're the actual data field names
- **Small files**: each file is single-responsibility, under ~100 lines, independently replaceable by AI
- **Types first**: all shared interfaces in `src/types/` with barrel exports
- **Hooks for logic**: game state and data loading live in hooks, components are presentational
- **Props down**: components receive data via props, no direct hook calls for shared state
- **No `useCallback`/`useMemo` in App**: React Compiler handles it. Hooks still use them since they aren't compiled the same way. If the compiler ESLint warns about mismatched deps, remove the manual memoization.
- **CSS**: flat single file `src/styles/index.css`, class-based, no CSS modules. Specificity matters — use `.parent.child` selectors when overriding base styles.

## Data

Two TopoJSON files generated by `scripts/prepare-data.mjs`:

- **`src/data/kommuner.json`** — 357 kommuner, each with properties: `{kommunenummer, navn, fylkesnummer, fylkenavn}`
- **`src/data/fylker.json`** — 15 fylker boundaries, each with: `{fylkesnummer, fylkenavn}`

The `kommunenummer` first 2 digits = `fylkesnummer`. This is how we link kommuner to fylker.

Run `node scripts/prepare-data.mjs` to regenerate from upstream (robhop/fylker-og-kommuner, CC BY 4.0).

## Project Structure

```
src/
├── types/
│   ├── geo.ts              # KommuneFeature, KommuneProperties, KommunePath
│   ├── game.ts             # GameMode, GameState
│   └── index.ts            # Barrel export
├── utils/
│   └── geo.ts              # Custom Mercator projection + viewBox computation
├── hooks/
│   ├── useMapData.ts       # Loads TopoJSON → KommuneFeature[]
│   ├── useGameState.ts     # Shuffle, guess, skip, restart, auto-reset on feature change
│   └── useTimer.ts         # Stopwatch (elapsed seconds, reset, formatTime)
├── components/
│   ├── Game.tsx            # NOT CURRENTLY USED — was an alternative architecture (see notes)
│   ├── map/
│   │   ├── GameMap.tsx      # SVG container: renders ALL kommuner, zooms viewBox to active subset
│   │   ├── KommuneShape.tsx # Single <path>, supports isSolved + isInactive states
│   │   ├── MagnifyingLens.tsx  # Circular zoom lens overlay
│   │   └── FylkeBorders.tsx # Internal fylke borders via topojson.mesh (always visible)
│   └── ui/
│       ├── GameHeader.tsx   # Target name, fylke hint, progress, errors, timer, skip, restart
│       ├── LensToggle.tsx   # Generic toggle button
│       └── FylkeSelector.tsx # Dropdown: "Hele Norge" or specific fylke
├── styles/
│   └── index.css           # All styles
├── App.tsx                  # Root orchestrator
└── main.tsx                 # Entry point
```

## Data Flow

```
App
├── useMapData() → features (all 357 kommuner, loaded once)
├── selectedFylke state → filters features into activeFeatures
├── useGameState(activeFeatures) → game state (auto-resets when features change)
├── useTimer(!isComplete) → elapsed time
│
├── GameHeader ← {currentName, currentFylke, showFylke, progress, errors, elapsed, onSkip, onRestart}
├── Toolbar
│   ├── FylkeSelector ← {fylker list, selected, onChange}
│   ├── LensToggle (lens)
│   └── LensToggle (fylke hint)
└── GameMap ← {allFeatures, activeFeatures, lensEnabled, solved, onGuess}
    ├── KommuneShape[] (ALL kommuner rendered, inactive ones dimmed)
    ├── FylkeBorders (always visible, internal borders only)
    └── MagnifyingLens (conditional, only shows active kommuner)
```

## Key File Details

### `src/utils/geo.ts` — Projection

Custom Mercator projection because d3's `fitSize` doesn't work with this TopoJSON data. Key function:

- `createPathGenerator(allFeatures)` → returns `{ pathGenerator, computeViewBox }`
- `pathGenerator` converts GeoJSON features to SVG path `d` strings
- `computeViewBox(subsetFeatures)` computes a viewBox that zooms to any subset while keeping the same projection. When subset === all, returns full Norway viewBox.

The projection is always based on ALL features (full Norway). This means all paths are in the same coordinate space regardless of which fylke is selected. The zoom is achieved by changing the SVG `viewBox`, not the projection.

### `src/components/map/GameMap.tsx` — Map Rendering

This is the most complex component. Key architecture:

- Receives `allFeatures` (all 357) and `activeFeatures` (filtered subset or all)
- Builds paths from `allFeatures` (everything is always rendered)
- Builds `activeSet` from `activeFeatures` for quick lookup
- `isFiltered = activeFeatures.length < allFeatures.length`
- Each KommuneShape gets `isInactive={isFiltered && !isActive}`
- ViewBox zooms to `activeFeatures` via `computeViewBox`
- Lens only shows `activePaths` (filtered to active kommuner)
- `noop` callback for inactive kommuner's `onSelect`

### `src/components/map/FylkeBorders.tsx` — Border Rendering

Uses `topojson.mesh(topology, object, (a, b) => a !== b)` to extract only internal borders (arcs shared by two different fylker). This eliminates coastline rendering. Rendered as a single `<path>` element, always visible, `pointer-events: none`.

### `src/hooks/useGameState.ts` — Game Logic

- Shuffles kommuner order on init
- Tracks: currentIndex, errors, solved set
- `handleGuess`: correct → mark solved + advance; wrong → increment errors
- `handleSkip`: append current target to end of order, advance index
- `handleRestart`: reshuffle, reset everything
- **Auto-reset on feature change**: uses `useRef` + `useEffect` to detect when the `features` array reference changes (fylke switch) and resets automatically

### `src/components/map/KommuneShape.tsx` — Individual Kommune

Memoized with `React.memo`. Builds className from state:
- Base: `kommune-shape`
- Solved: `kommune-solved` (green)
- Inactive: `kommune-inactive` (dimmed, not clickable)

### `src/components/Game.tsx` — NOT IN USE

This was created as an alternative architecture where Game encapsulates game state + timer and gets remounted via `key` when fylke changes. The current App.tsx does NOT use this — it manages game state directly. This file can be deleted or repurposed.

## Current CSS Color Scheme

| Element | Color | Hex |
|---------|-------|-----|
| Page background | Near black | `#0a0a0f` |
| SVG/ocean background | Black | `#000000` |
| Active unsolved kommune | Dark slate | `#1e293b` |
| Active hover | Lighter slate | `#334155` |
| Solved kommune | Dark green | `#166534` |
| Inactive kommune | Dark purple-grey | `#1a1a2e` |
| Kommune stroke | Near black | `#0a0a0f` |
| Inactive stroke | Dark grey | `#2a2a3e` |
| Fylke borders | White 25% | `rgba(255,255,255,0.25)` |
| Target text | Blue | `#60a5fa` |
| Error count | Red | `#f87171` |
| Complete text | Green | `#4ade80` |
| Muted text | Slate | `#94a3b8` |

## Known Bug: Inactive Kommune Color Not Applying

**Problem**: When selecting a fylke (e.g. Akershus), kommuner from other fylker (e.g. Oslo) should appear in `#1a1a2e` (dark purple-grey), distinct from both the black ocean and the active slate kommuner. The CSS rule `.kommune-shape.kommune-inactive` exists with the correct color, but the inactive kommuner still appear the same color as active ones.

**Suspected cause**: CSS specificity or the class not being applied. Debug steps:
1. Inspect an inactive kommune in browser DevTools — check if `kommune-inactive` class is present
2. If class IS present: it's a CSS specificity issue. Try `!important` or restructure selectors
3. If class is NOT present: the `isInactive` prop isn't being passed correctly. Check that `GameMap` receives both `allFeatures` and `activeFeatures` as separate props (not just `features`)
4. Check that `isFiltered` is `true` when a fylke is selected
5. The `memo()` on KommuneShape could prevent re-render if props don't change reference — verify `isInactive` actually transitions from `undefined`/`false` to `true`

**This is the first thing to fix in the next session.**

## Features Implemented

- ✅ Click-to-guess game with 357 kommuner
- ✅ Magnifying lens (3x zoom, toggleable)
- ✅ Fylke hint toggle (shows fylke name next to target)
- ✅ Fylke borders (always visible, internal only)
- ✅ Skip button (re-queues kommune at end)
- ✅ Timer (mm:ss, stops on completion)
- ✅ Restart (reshuffle + reset)
- ✅ Fylke selector (play just one fylke, map zooms to fit)
- ⚠️ Inactive fylke coloring (CSS exists but not working — see bug above)

## Wishlist / Next Features

1. **Fix inactive kommune coloring** (see bug above)
2. **Write mode** — type kommune name instead of clicking (autocomplete input)
3. **Score persistence** — localStorage best times per fylke
4. **Mobile support** — touch handling, responsive layout
5. **Accessibility** — keyboard navigation, ARIA labels

## Notes for AI

- Always check `ARCHITECTURE.md` in the repo (but this document is more current)
- The Game.tsx component is dead code — App.tsx handles everything directly
- When modifying CSS, use high-specificity selectors (`.kommune-shape.kommune-inactive`) because the base `.kommune-shape` has `fill` set
- The projection in `geo.ts` is the most sensitive code — changing it breaks the entire map
- `useGameState` auto-resets when its `features` array reference changes, so switching fylke triggers a game reset without needing explicit reset calls (though timer needs manual reset via `resetTimer()`)
- All TopoJSON parsing happens at build time (static imports), no runtime fetches
- FylkeBorders uses `mesh` not `feature` — this is important for getting only internal borders